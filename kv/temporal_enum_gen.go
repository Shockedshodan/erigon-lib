// Code generated by "enumer -type Domain,History,InvertedIdx --output temporal_enum_gen.go -gqlgen -json -text -yaml"; DO NOT EDIT.

package kv

import (
	"encoding/json"
	"fmt"
	"io"
	"strconv"
	"strings"
)

const _DomainName = "AccountsDomainStorageDomainCodeDomainCommitmentDomainCodeSizeFakeDomain"

var _DomainIndex = [...]uint8{0, 14, 27, 37, 53, 71}

const _DomainLowerName = "accountsdomainstoragedomaincodedomaincommitmentdomaincodesizefakedomain"

func (i Domain) String() string {
	if i < 0 || i >= Domain(len(_DomainIndex)-1) {
		return fmt.Sprintf("Domain(%d)", i)
	}
	return _DomainName[_DomainIndex[i]:_DomainIndex[i+1]]
}

// An "invalid array index" compiler error signifies that the constant values have changed.
// Re-run the stringer command to generate them again.
func _DomainNoOp() {
	var x [1]struct{}
	_ = x[AccountsDomain-(0)]
	_ = x[StorageDomain-(1)]
	_ = x[CodeDomain-(2)]
	_ = x[CommitmentDomain-(3)]
	_ = x[CodeSizeFakeDomain-(4)]
}

var _DomainValues = []Domain{AccountsDomain, StorageDomain, CodeDomain, CommitmentDomain, CodeSizeFakeDomain}

var _DomainNameToValueMap = map[string]Domain{
	_DomainName[0:14]:       AccountsDomain,
	_DomainLowerName[0:14]:  AccountsDomain,
	_DomainName[14:27]:      StorageDomain,
	_DomainLowerName[14:27]: StorageDomain,
	_DomainName[27:37]:      CodeDomain,
	_DomainLowerName[27:37]: CodeDomain,
	_DomainName[37:53]:      CommitmentDomain,
	_DomainLowerName[37:53]: CommitmentDomain,
	_DomainName[53:71]:      CodeSizeFakeDomain,
	_DomainLowerName[53:71]: CodeSizeFakeDomain,
}

var _DomainNames = []string{
	_DomainName[0:14],
	_DomainName[14:27],
	_DomainName[27:37],
	_DomainName[37:53],
	_DomainName[53:71],
}

// DomainString retrieves an enum value from the enum constants string name.
// Throws an error if the param is not part of the enum.
func DomainString(s string) (Domain, error) {
	if val, ok := _DomainNameToValueMap[s]; ok {
		return val, nil
	}

	if val, ok := _DomainNameToValueMap[strings.ToLower(s)]; ok {
		return val, nil
	}
	return 0, fmt.Errorf("%s does not belong to Domain values", s)
}

// DomainValues returns all values of the enum
func DomainValues() []Domain {
	return _DomainValues
}

// DomainStrings returns a slice of all String values of the enum
func DomainStrings() []string {
	strs := make([]string, len(_DomainNames))
	copy(strs, _DomainNames)
	return strs
}

// IsADomain returns "true" if the value is listed in the enum definition. "false" otherwise
func (i Domain) IsADomain() bool {
	for _, v := range _DomainValues {
		if i == v {
			return true
		}
	}
	return false
}

// MarshalJSON implements the json.Marshaler interface for Domain
func (i Domain) MarshalJSON() ([]byte, error) {
	return json.Marshal(i.String())
}

// UnmarshalJSON implements the json.Unmarshaler interface for Domain
func (i *Domain) UnmarshalJSON(data []byte) error {
	var s string
	if err := json.Unmarshal(data, &s); err != nil {
		return fmt.Errorf("Domain should be a string, got %s", data)
	}

	var err error
	*i, err = DomainString(s)
	return err
}

// MarshalText implements the encoding.TextMarshaler interface for Domain
func (i Domain) MarshalText() ([]byte, error) {
	return []byte(i.String()), nil
}

// UnmarshalText implements the encoding.TextUnmarshaler interface for Domain
func (i *Domain) UnmarshalText(text []byte) error {
	var err error
	*i, err = DomainString(string(text))
	return err
}

// MarshalYAML implements a YAML Marshaler for Domain
func (i Domain) MarshalYAML() (interface{}, error) {
	return i.String(), nil
}

// UnmarshalYAML implements a YAML Unmarshaler for Domain
func (i *Domain) UnmarshalYAML(unmarshal func(interface{}) error) error {
	var s string
	if err := unmarshal(&s); err != nil {
		return err
	}

	var err error
	*i, err = DomainString(s)
	return err
}

// MarshalGQL implements the graphql.Marshaler interface for Domain
func (i Domain) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(i.String()))
}

// UnmarshalGQL implements the graphql.Unmarshaler interface for Domain
func (i *Domain) UnmarshalGQL(value interface{}) error {
	str, ok := value.(string)
	if !ok {
		return fmt.Errorf("Domain should be a string, got %T", value)
	}

	var err error
	*i, err = DomainString(str)
	return err
}

const _HistoryName = "AccountsHistoryStorageHistoryCodeHistoryCommitmentHistory"

var _HistoryIndex = [...]uint8{0, 15, 29, 40, 57}

const _HistoryLowerName = "accountshistorystoragehistorycodehistorycommitmenthistory"

func (i History) String() string {
	if i < 0 || i >= History(len(_HistoryIndex)-1) {
		return fmt.Sprintf("History(%d)", i)
	}
	return _HistoryName[_HistoryIndex[i]:_HistoryIndex[i+1]]
}

// An "invalid array index" compiler error signifies that the constant values have changed.
// Re-run the stringer command to generate them again.
func _HistoryNoOp() {
	var x [1]struct{}
	_ = x[AccountsHistory-(0)]
	_ = x[StorageHistory-(1)]
	_ = x[CodeHistory-(2)]
	_ = x[CommitmentHistory-(3)]
}

var _HistoryValues = []History{AccountsHistory, StorageHistory, CodeHistory, CommitmentHistory}

var _HistoryNameToValueMap = map[string]History{
	_HistoryName[0:15]:       AccountsHistory,
	_HistoryLowerName[0:15]:  AccountsHistory,
	_HistoryName[15:29]:      StorageHistory,
	_HistoryLowerName[15:29]: StorageHistory,
	_HistoryName[29:40]:      CodeHistory,
	_HistoryLowerName[29:40]: CodeHistory,
	_HistoryName[40:57]:      CommitmentHistory,
	_HistoryLowerName[40:57]: CommitmentHistory,
}

var _HistoryNames = []string{
	_HistoryName[0:15],
	_HistoryName[15:29],
	_HistoryName[29:40],
	_HistoryName[40:57],
}

// HistoryString retrieves an enum value from the enum constants string name.
// Throws an error if the param is not part of the enum.
func HistoryString(s string) (History, error) {
	if val, ok := _HistoryNameToValueMap[s]; ok {
		return val, nil
	}

	if val, ok := _HistoryNameToValueMap[strings.ToLower(s)]; ok {
		return val, nil
	}
	return 0, fmt.Errorf("%s does not belong to History values", s)
}

// HistoryValues returns all values of the enum
func HistoryValues() []History {
	return _HistoryValues
}

// HistoryStrings returns a slice of all String values of the enum
func HistoryStrings() []string {
	strs := make([]string, len(_HistoryNames))
	copy(strs, _HistoryNames)
	return strs
}

// IsAHistory returns "true" if the value is listed in the enum definition. "false" otherwise
func (i History) IsAHistory() bool {
	for _, v := range _HistoryValues {
		if i == v {
			return true
		}
	}
	return false
}

// MarshalJSON implements the json.Marshaler interface for History
func (i History) MarshalJSON() ([]byte, error) {
	return json.Marshal(i.String())
}

// UnmarshalJSON implements the json.Unmarshaler interface for History
func (i *History) UnmarshalJSON(data []byte) error {
	var s string
	if err := json.Unmarshal(data, &s); err != nil {
		return fmt.Errorf("History should be a string, got %s", data)
	}

	var err error
	*i, err = HistoryString(s)
	return err
}

// MarshalText implements the encoding.TextMarshaler interface for History
func (i History) MarshalText() ([]byte, error) {
	return []byte(i.String()), nil
}

// UnmarshalText implements the encoding.TextUnmarshaler interface for History
func (i *History) UnmarshalText(text []byte) error {
	var err error
	*i, err = HistoryString(string(text))
	return err
}

// MarshalYAML implements a YAML Marshaler for History
func (i History) MarshalYAML() (interface{}, error) {
	return i.String(), nil
}

// UnmarshalYAML implements a YAML Unmarshaler for History
func (i *History) UnmarshalYAML(unmarshal func(interface{}) error) error {
	var s string
	if err := unmarshal(&s); err != nil {
		return err
	}

	var err error
	*i, err = HistoryString(s)
	return err
}

// MarshalGQL implements the graphql.Marshaler interface for History
func (i History) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(i.String()))
}

// UnmarshalGQL implements the graphql.Unmarshaler interface for History
func (i *History) UnmarshalGQL(value interface{}) error {
	str, ok := value.(string)
	if !ok {
		return fmt.Errorf("History should be a string, got %T", value)
	}

	var err error
	*i, err = HistoryString(str)
	return err
}

const _InvertedIdxName = "AccountsHistoryIdxStorageHistoryIdxCodeHistoryIdxCommitmentHistoryIdxLogTopicIdxLogAddrIdxTracesFromIdxTracesToIdx"

var _InvertedIdxIndex = [...]uint8{0, 18, 35, 49, 69, 80, 90, 103, 114}

const _InvertedIdxLowerName = "accountshistoryidxstoragehistoryidxcodehistoryidxcommitmenthistoryidxlogtopicidxlogaddridxtracesfromidxtracestoidx"

func (i InvertedIdx) String() string {
	if i < 0 || i >= InvertedIdx(len(_InvertedIdxIndex)-1) {
		return fmt.Sprintf("InvertedIdx(%d)", i)
	}
	return _InvertedIdxName[_InvertedIdxIndex[i]:_InvertedIdxIndex[i+1]]
}

// An "invalid array index" compiler error signifies that the constant values have changed.
// Re-run the stringer command to generate them again.
func _InvertedIdxNoOp() {
	var x [1]struct{}
	_ = x[AccountsHistoryIdx-(0)]
	_ = x[StorageHistoryIdx-(1)]
	_ = x[CodeHistoryIdx-(2)]
	_ = x[CommitmentHistoryIdx-(3)]
	_ = x[LogTopicIdx-(4)]
	_ = x[LogAddrIdx-(5)]
	_ = x[TracesFromIdx-(6)]
	_ = x[TracesToIdx-(7)]
}

var _InvertedIdxValues = []InvertedIdx{AccountsHistoryIdx, StorageHistoryIdx, CodeHistoryIdx, CommitmentHistoryIdx, LogTopicIdx, LogAddrIdx, TracesFromIdx, TracesToIdx}

var _InvertedIdxNameToValueMap = map[string]InvertedIdx{
	_InvertedIdxName[0:18]:         AccountsHistoryIdx,
	_InvertedIdxLowerName[0:18]:    AccountsHistoryIdx,
	_InvertedIdxName[18:35]:        StorageHistoryIdx,
	_InvertedIdxLowerName[18:35]:   StorageHistoryIdx,
	_InvertedIdxName[35:49]:        CodeHistoryIdx,
	_InvertedIdxLowerName[35:49]:   CodeHistoryIdx,
	_InvertedIdxName[49:69]:        CommitmentHistoryIdx,
	_InvertedIdxLowerName[49:69]:   CommitmentHistoryIdx,
	_InvertedIdxName[69:80]:        LogTopicIdx,
	_InvertedIdxLowerName[69:80]:   LogTopicIdx,
	_InvertedIdxName[80:90]:        LogAddrIdx,
	_InvertedIdxLowerName[80:90]:   LogAddrIdx,
	_InvertedIdxName[90:103]:       TracesFromIdx,
	_InvertedIdxLowerName[90:103]:  TracesFromIdx,
	_InvertedIdxName[103:114]:      TracesToIdx,
	_InvertedIdxLowerName[103:114]: TracesToIdx,
}

var _InvertedIdxNames = []string{
	_InvertedIdxName[0:18],
	_InvertedIdxName[18:35],
	_InvertedIdxName[35:49],
	_InvertedIdxName[49:69],
	_InvertedIdxName[69:80],
	_InvertedIdxName[80:90],
	_InvertedIdxName[90:103],
	_InvertedIdxName[103:114],
}

// InvertedIdxString retrieves an enum value from the enum constants string name.
// Throws an error if the param is not part of the enum.
func InvertedIdxString(s string) (InvertedIdx, error) {
	if val, ok := _InvertedIdxNameToValueMap[s]; ok {
		return val, nil
	}

	if val, ok := _InvertedIdxNameToValueMap[strings.ToLower(s)]; ok {
		return val, nil
	}
	return 0, fmt.Errorf("%s does not belong to InvertedIdx values", s)
}

// InvertedIdxValues returns all values of the enum
func InvertedIdxValues() []InvertedIdx {
	return _InvertedIdxValues
}

// InvertedIdxStrings returns a slice of all String values of the enum
func InvertedIdxStrings() []string {
	strs := make([]string, len(_InvertedIdxNames))
	copy(strs, _InvertedIdxNames)
	return strs
}

// IsAInvertedIdx returns "true" if the value is listed in the enum definition. "false" otherwise
func (i InvertedIdx) IsAInvertedIdx() bool {
	for _, v := range _InvertedIdxValues {
		if i == v {
			return true
		}
	}
	return false
}

// MarshalJSON implements the json.Marshaler interface for InvertedIdx
func (i InvertedIdx) MarshalJSON() ([]byte, error) {
	return json.Marshal(i.String())
}

// UnmarshalJSON implements the json.Unmarshaler interface for InvertedIdx
func (i *InvertedIdx) UnmarshalJSON(data []byte) error {
	var s string
	if err := json.Unmarshal(data, &s); err != nil {
		return fmt.Errorf("InvertedIdx should be a string, got %s", data)
	}

	var err error
	*i, err = InvertedIdxString(s)
	return err
}

// MarshalText implements the encoding.TextMarshaler interface for InvertedIdx
func (i InvertedIdx) MarshalText() ([]byte, error) {
	return []byte(i.String()), nil
}

// UnmarshalText implements the encoding.TextUnmarshaler interface for InvertedIdx
func (i *InvertedIdx) UnmarshalText(text []byte) error {
	var err error
	*i, err = InvertedIdxString(string(text))
	return err
}

// MarshalYAML implements a YAML Marshaler for InvertedIdx
func (i InvertedIdx) MarshalYAML() (interface{}, error) {
	return i.String(), nil
}

// UnmarshalYAML implements a YAML Unmarshaler for InvertedIdx
func (i *InvertedIdx) UnmarshalYAML(unmarshal func(interface{}) error) error {
	var s string
	if err := unmarshal(&s); err != nil {
		return err
	}

	var err error
	*i, err = InvertedIdxString(s)
	return err
}

// MarshalGQL implements the graphql.Marshaler interface for InvertedIdx
func (i InvertedIdx) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(i.String()))
}

// UnmarshalGQL implements the graphql.Unmarshaler interface for InvertedIdx
func (i *InvertedIdx) UnmarshalGQL(value interface{}) error {
	str, ok := value.(string)
	if !ok {
		return fmt.Errorf("InvertedIdx should be a string, got %T", value)
	}

	var err error
	*i, err = InvertedIdxString(str)
	return err
}
